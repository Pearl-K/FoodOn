# 캐시 전략 최적화로 메인 조회 API 병목 제거
**애플리케이션 로직에서의 계산 비용 최소화 + p95 응답 시간 30% 단축**

## 개요
해당 문서는 메인 화면의 섭취 기록 캘린더 API 응답 속도를 최적화하기 위한 성능 개선 문서입니다.
주요 목표는 아래와 같습니다.


- 반복적인 애플리케이션 계산 비용 제거
- 캐시 구조 최적화로 캐시 무효화 최소화, hit rate 향상
- 부하 테스트(k6) 기반 응답 시간 수치 개선 (`p95` 기준 30% 단축)


---
## 1. 문제 인식

### 최적화 접근

### Database 계층
- N+1 현상은 fetch join 으로 한 번에 가져오도록 변경
- 쿼리 자체에 큰 성능 병목 없고, 인덱싱 적절(모든 쿼리 인덱싱 잘 탐)

### Application 로직
- 특정 월의 모든 일일 섭취량을 가져오는 캘린더 API 계산 비용 큼
- 사용자의 상태 이력, 활동량, 섭취 로그 등 다양한 도메인을 조합해야 함
- 캐시 미스 시 매번 `TreeMap` 재생성 + per-day 계산이 반복됨


기존 로직 흐름은 아래와 같다.
```text
[Start] → [getAllDatesInMonth()]
           ↓
     [find MemberStatus] → TreeMap
           ↓
     [find ActivityLevels] → Map
           ↓
     [find IntakeLogs] → Map
           ↓
     [loop allDates]
        ├─> [if in cache] → use
        └─> [else] → [convertToIntakeSummaryResponse()]
                        └─> [calculate goalKcal]
           ↓
[Accumulate into List] → [Return]

```

- 해당 로직은 다양한 테이블의 조회와, 날짜 기반의 TreeMap 탐색이 순차적으로 일어난다.
- 회원의 활동량(`ActivityLevel`)과 상태기록(`MemberStatus`)이 수시로 변경될 수 있다.
  - 해당 변경은 `goalKcal` 계산에 큰 영향을 주는 변수이기 때문에 로직 변경이 불가능하다.
  - `TreeMap`에서 `floorEntry`를 돌며 변경 지점을 찾는 대신, DB에 모든 날짜별 정보를 저장하여 계산을 단순화 하는 방법도 존재했다.
  - But, 위 방식은 회원이 많아졌을 때 무의미한 레코드(변경이 없을 때의 레코드)가 DB에 쌓여서 용량 관리에 단점이 있었다 → 애플리케이션 계층 계산으로 유지 


### Cache 계층 (식사 기록 추가 시, 매번 캐시 무효화되는 문제점)
- Spring Cache 기반의 `@Cachable` 어노테이션으로 단순 `String` 타입 캐싱
- 섭취 기록 1건 추가 시, 캘린더 전체 캐시 `@CacheEvict`
- 즉, 사용자가 한 끼만 추가 등록하더라도 한 달치를 계산해놓은 기존 캐시가 삭제됨
- 매번 꾸준히 식사를 기록하는 사용자(active user)일수록 캐시 효율 나쁨 → 오히려 계산 비용만 소모


## 2. 개선 전략
애플리케이션 로직 측면에서, 최대 30일 정도의 `TreeMap` 계산 자체는 효율이 나쁘지 않다.


병목 원인은 write 할 때마다 캐시가 무효화되어 매번 cache-miss & 재계산이 발생한다는 점이다.


DB 저장 구조를 변경해서 무의미한 레코드를 늘리거나, 애플리케이션에서 3개의 독립적인 쿼리를 병렬 처리로 가져오는 최적화 등은 과한 비용 소모이다.

#### → 캐시 구조를 근본적으로 개선하고 hit-rate를 높이는 것이 투자 비용 대비 효과가 크다.


### 2-1. 캐시 구조 변경 (Redis Hash 자료구조로 변경)
- 기존: Key 단위 → calendar:{userId}:{yearMonth}
- 변경: Hash 타입으로 개별 날짜 필드만 관리 & 갱신 (과거 기록은 그대로 유지)
- List 자료구조와 비교
  - 시간에 따라 순차적으로 기록이 쌓이는 구조라면 List 도 괜찮았을 것이다.
  - 그러나, 사용자가 과거 특정 시점에 섭취했던 기록을 추가하거나 변경할 수도 있다.
  - 따라서, 요소 간 랜덤 액세스에 비효율적인 List 타입을 고려 대상에서 제외했다.

```text
Key   : user:{userId}:intake:{yyyy-MM}
Type  : Redis Hash
Field : yyyy-MM-dd
Value : JSON(IntakeSummaryResponse)
```

### 2-2. TTL 전략
- 기존 전략: 모든 TTL 고정 값
- 변경 전략: 조회 시 TTL 갱신을 통해 자주 보는 최신 데이터 TTL 유지, 과거 데이터는 자연스럽게 만료


### 2-3. Redis 메모리 관리 정책 설정
| 정책             | 설명                |
| -------------- | ----------------- |
| `volatile-lru` | TTL 있는 키 중 LRU 제거 |
| `volatile-ttl` | TTL 가장 짧은 키 제거    |
| `allkeys-lru`  | 전체 키 중 LRU 제거     |
| `noeviction`   | 기본값, 메모리 초과 시 에러  |
| `volatile-lfu` | 사용 횟수 기반 제거       |




## 3. 개선 결과 (k6 부하 테스트 기반)
| 구분             | 개선 전  | 개선 후                 |
| -------------- |-------| -------------------- |
| 평균 응답 시간 (`p95`) | 460ms | **320ms (-30%)**     |
| 캐시 히트율         | 35%   | **83%**              |
| GC 빈도          | 높음    | **낮음 (캐시 반복 계산 제거)** |
| DB 부하          | 높음    | **낮음 (쿼리 수 1/3 감소)** |



---
## 결론
- 기존 구조는 계산 로직은 적절한 편이나, 캐시 전략이 비효율적이었음
- 캐시 단위를 해당 월-날짜 별로 세분화하고 TTL 전략을 도입하여 아래와 같은 결과 도출
  - 고비용 로직의 계산 빈도 감소
  - 메인 화면 캘린더 API 응답 속도 개선 
  - 시스템 부하 감소, hit-rate 상승